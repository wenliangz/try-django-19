# 1. Model (model.py)
- Define a Model in Django

# 2. Django(Admin App) View for managing data in Model: (admin.py)
Edit applicationâ€™s models in the admin interface.
- register user model
- customize user model by defining a class
- this view is for the administrator to use; designed and contributed by Django
- the view on the admin site could be served as mimic to create our own view
- URL: /admin/

# 3. Our own View for managing data data in Model: (view.py)
- this view is for the end user to use
- URL is controled by controller (URL.py)
- Model View Controller (MVC)
- CRUD: 
    - CREATE -- POST --Make new
    - RETRIEVE -- GET -- List/Search
    - UPDATE -- PUT/PATCH --EDIT
    - DELETE -- DELETE --delete
- Create first View
- Request&Response Cycle
    - Request: User click a link on web(different link may have different request)  -- knock the door
        - GET; POST;PUT; DELETE
    - Resposne: Sever returns a response  -- answer the door
- View functions is what the server use to handle the request and return response; so the view function always take request object and return response object(most of the time, the type of response is HttpResponse)
-  URL.py is used to map each request(url link) to the corresponding view function for handling
    
# 4. Mapping URLs to Views
- two ways of writing url mapping
    - absolute path, better
    - potential problems with multile apps with multiple views; can use "import view as"
    - In App Views: 
        - use include function in the main url.py; 
        - create and define each app's own url.py in each app folder
        - notice: no '$' sign at the end of url pattern in main folder, in order to delegate the pattern to the app's url patten 
     
# 5. Template
Template allows us to make webpage smarter, coding more efficient.
- BASE_DIR (settings.py): where the local computer manage.py is
- TEMPLATE DIR: os.path.join(BASE_DIR,'templates'). 
- render function to render template and return httpresponse,take three arguments:
    - request object(contains variables from httprequest)
    - template
    - context object (user defined or generated by view functions)
- define context to pass variables to render function to render template, which make template more dynamic
- variable syntax in template: {{variable}}
- change context or template based on conditions in the view function
- if we can use data querry from our data model(Querry data) for the context, the template will be more dynamic

# 6. QuerySet Basics
- Test queryset in shell(data query from data model): python manage.py shell (the django-related python shell)
- Model Manager: Each Model has a special attribute, called objects by default. This attribute is another class object which encapusulate data from the model and operation methods to perform database queries, such as all(),filter(),create(),get()
    - Use Querryset(e.g. objects.all()) in our view by adding querryset into our context for rendering template on list view
    - Get Item or 404 Query(e.g. objects.get(id=3)): 
        - Get one item from queryset and display in detail view if item not exits, 
        - import get_object_or_404 for display the standard 404 error to prevent from end user to see the exception errors raised by django, e.g. instance= get_object_or_404(Post,id=1)


# Make everything dynamic! CODE for Dynamic
- Make URL more dynamic:
    - use Regular expression for RUL routing (from URL to view function)
    - **named URL**,named in url pattern and passed to the template. One tip for preventing overlap named URLs in the case of multiple webapp: use **namespace** in the include() function in the main url.py to restrict the scope of the named URL in each app. please note if you used namesapce, you will have to write named URL as <namespace:named URL>
    - URL links and Get Absolute URL(get_absolute_url) (from template to URL)
- Make View more dynamic:
    - Rendering template with context variables, different kinds variables:
        - user defined variables in context object
        - pass variable from URL regular expression to view function
        - pass request object to view function (request context)
        - 
    - template tag and inheritance

------------------------------------------
#7. Dynamic URL Routing and Pattens
- Use python regular expressionin for URL patterns such as  r'^detail/(?P<id>\d+)/$'. The variable in the RE will be passed to the view function, which will need to take this variable (from URL to view function)
- make URL links more dynamic ( two ways to prevent hard-coding)
    - hard-coded links in the template: href = "/posts/{{obj.id}}"
    - instead of using hard-coded link, used named url, but notice that we still need to pass the variable to URL.  e.g.: href = {% url 'detail' id=obj.id %} (better than hard-coding)
    - Get Absolute URL (more dynamic solution): defined directly in our model by using get_absolute_url function, to associate the url to the actual model instance itself. In order to prevent hard-coding in the get absolute url function, we need to import django reverse function(from django.core.urlresolvers import reverse) and pass the named url and keyword argument. e.g. instead of return '/posts/%s'%(self.id), we return reverse('detail',kwargs={'id':self.id})
    
**IMPORTANT to Remember:**
 Model instance can not only pass the actual data in the model to the template, but can also pass **user defined function instance** encapsulated in the model manager and can be access the same way as field attribute by dot notation. 



    
    