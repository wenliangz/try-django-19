# 1. Model (model.py)
- Define a Model in Django

# 2. Django(Admin App) View for managing data in Model: (admin.py)
Edit applicationâ€™s models in the admin interface.
- register user model
- customize user model by defining a class
- this view is for the administrator to use; designed and contributed by Django
- the view on the admin site could be served as mimic to create our own view
- URL: /admin/

# 3. Our own View for managing data data in Model: (view.py)
- this view is for the end user to use
- URL is controled by controller (URL.py)
- Model View Controller (MVC)
- CRUD: 
    - CREATE -- POST --Make new
    - RETRIEVE -- GET -- List/Search
    - UPDATE -- PUT/PATCH --EDIT
    - DELETE -- DELETE --delete
- Create first View
- Request&Response Cycle
    - Request: User click a link on web(different link may have different request)  -- knock the door
        - GET; POST;PUT; DELETE
    - Resposne: Sever returns a response  -- answer the door
- View functions is what the server use to handle the request and return response; so the view function always take request object and return response object(most of the time, the type of response is HttpResponse)
-  URL.py is used to map each request(url link) to the corresponding view function for handling
    
# 4. Mapping URLs to Views
- two ways of writing url mapping
    - absolute path, better
    - potential problems with multile apps with multiple views; can use "import view as"
    - In App Views: 
        - use include function in the main url.py; 
        - create and define each app's own url.py in each app folder
        - notice: no '$' sign at the end of url pattern in main folder, in order to delegate the pattern to the app's url patten 
     
# 5. Template
Template allows us to make webpage smarter, coding more efficient.
- BASE_DIR (settings.py): where the local computer manage.py is
- TEMPLATE DIR: os.path.join(BASE_DIR,'templates'). 
- render function to render template and return httpresponse,take three arguments:
    - request object(contains variables from httprequest)
    - template
    - context object (user defined or generated by view functions)
- define context to pass variables to render function to render template, which make template more dynamic
- variable syntax in template: {{variable}}
- change context or template based on conditions in the view function
- if we can use data querry from our data model(Querry data) for the context, the template will be more dynamic

# 6. QuerySet Basics
- Test queryset in shell(data query from data model): python manage.py shell (the django-related python shell)
- Model Manager: Each Model has a special attribute, called objects by default. This attribute is another class object which encapusulate data from the model and operation methods to perform database queries, such as all(),filter(),create(),get()
    - Use Querryset(e.g. objects.all()) in our view by adding querryset into our context for rendering template on list view
    - Get Item or 404 Query(e.g. objects.get(id=3)): 
        - Get one item from queryset and display in detail view if item not exits, 
        - import get_object_or_404 for display the standard 404 error to prevent from end user to see the exception errors raised by django, e.g. instance= get_object_or_404(Post,id=1)


# Make everything dynamic!
- Make URL more dynamic:
    - use Regular expression for RUL routing
    - named URL
    - URL links and Get Absolute URL(get_absolute_url)
- Make View more dynamic:
    - Rendering template with context variables, different kinds variables:
        - user defined variables in context object
        - pass variable from URL regular expression to view function
        - pass request object to view function (request context)
        - 
    - template tag and inheritance

------------------------------------------
#7. Dynamic URL Routing and Pattens
- Use python regular expressionin for URL patterns such as  r'^detail/(?P<id>\d+)/$'. The variable in the RE will be passed to the view function, which will need to take this variable


    
    